# ===========================================
# Zsh configuration
# ===========================================

# ---------------------
# Path (must be first)
# ---------------------
# Homebrew
if [[ -f /opt/homebrew/bin/brew ]]; then
    eval "$(/opt/homebrew/bin/brew shellenv)"
fi

# Local bin
export PATH="$HOME/.local/bin:$PATH"

# ---------------------
# History
# ---------------------
HISTFILE=~/.zsh_history
HISTSIZE=10000
SAVEHIST=10000
setopt SHARE_HISTORY
setopt HIST_IGNORE_DUPS
setopt HIST_IGNORE_SPACE

# ---------------------
# Options
# ---------------------
setopt AUTO_CD
setopt AUTO_PUSHD
setopt CORRECT

# ---------------------
# Aliases
# ---------------------
alias vim="nvim"
alias vi="nvim"
alias lg="lazygit"
alias g="git"
alias gs="git status"
alias ga="git add"
alias gc="git commit"
alias gp="git push"
alias gl="git pull"

# eza (modern ls)
if command -v eza &> /dev/null; then
    alias ls="eza --icons"
    alias ll="eza -la --icons"
    alias la="eza -a --icons"
    alias lt="eza --tree --icons"
fi

# bat (modern cat)
if command -v bat &> /dev/null; then
    alias cat="bat --paging=never"
fi

# ---------------------
# Starship prompt
# ---------------------
if command -v starship &> /dev/null; then
    eval "$(starship init zsh)"
fi

# ---------------------
# Zoxide (smart cd)
# ---------------------
if command -v zoxide &> /dev/null; then
    eval "$(zoxide init zsh)"
    alias cd="z"
fi

# ---------------------
# fzf
# ---------------------
if command -v fzf &> /dev/null; then
    # fzf key bindings and completion
    source <(fzf --zsh)

    # fzf options
    export FZF_DEFAULT_OPTS="
        --height 40%
        --layout=reverse
        --border
        --inline-info
        --color=fg:#c0caf5,bg:#1a1b26,hl:#bb9af7
        --color=fg+:#c0caf5,bg+:#292e42,hl+:#7dcfff
        --color=info:#7aa2f7,prompt:#7dcfff,pointer:#7dcfff
        --color=marker:#9ece6a,spinner:#9ece6a,header:#9ece6a
    "

    # Use fd for fzf if available
    if command -v fd &> /dev/null; then
        export FZF_DEFAULT_COMMAND="fd --type f --hidden --follow --exclude .git"
        export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
        export FZF_ALT_C_COMMAND="fd --type d --hidden --follow --exclude .git"
    fi
fi

# ---------------------
# mise (version manager)
# ---------------------
if command -v mise &> /dev/null; then
    eval "$(mise activate zsh)"
fi

# ---------------------
# ghq + fzf (repository management)
# ---------------------
if command -v ghq &> /dev/null; then
    export GHQ_ROOT="$HOME/ghq"

    # ghq + fzf: Ctrl+g to jump to repository
    function ghq-fzf() {
        local repo=$(ghq list | fzf --preview "eza --icons --tree --level=1 $(ghq root)/{}")
        if [ -n "$repo" ]; then
            cd "$(ghq root)/$repo"
        fi
    }
    zle -N ghq-fzf
    bindkey '^g' ghq-fzf

    # Alias
    alias repos="ghq-fzf"
fi

# ---------------------
# Git worktree + fzf
# ---------------------
# gwt: Select and cd to worktree with fzf
function gwt() {
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        echo "Not a git repository"
        return 1
    fi
    local selected=$(git worktree list | fzf --preview 'git log --oneline -10 {2}' | awk '{print $1}')
    if [ -n "$selected" ]; then
        cd "$selected"
    fi
}

# Patterns to exclude from worktree copy (dirs and large files)
GWT_COPY_EXCLUDE=(node_modules .git dist build coverage __pycache__ .venv venv "*.log")

# gwta: Add new worktree (creates in parent directory)
function gwta() {
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        echo "Not a git repository"
        return 1
    fi
    local branch="$1"
    if [ -z "$branch" ]; then
        # If no branch specified, select from remote branches with fzf
        branch=$(git branch -r | sed 's/origin\///' | fzf --prompt="Select branch: ")
        branch=$(echo "$branch" | xargs)  # trim whitespace
    fi
    if [ -z "$branch" ]; then
        echo "No branch selected"
        return 1
    fi
    local repo_root=$(git rev-parse --show-toplevel)
    local repo_name=$(basename "$repo_root")
    local worktree_path="$(dirname "$repo_root")/${repo_name}-${branch}"

    if git worktree add "$worktree_path" "$branch"; then
        # Copy gitignored files (excluding directories and large files)
        local copied=()
        local files=(${(f)"$(git -C "$repo_root" ls-files --others --ignored --exclude-standard)"})
        for f in "${files[@]}"; do
            [[ -f "$repo_root/$f" ]] || continue
            local basename=$(basename "$f")
            local skip=false
            for exclude in "${GWT_COPY_EXCLUDE[@]}"; do
                if [[ "$basename" == $~exclude ]]; then
                    skip=true
                    break
                fi
            done
            if ! $skip; then
                local dest_dir="$worktree_path/$(dirname "$f")"
                mkdir -p "$dest_dir"
                cp "$repo_root/$f" "$dest_dir/"
                copied+=("$f")
            fi
        done
        if [[ ${#copied[@]} -gt 0 ]]; then
            echo "Copied ${#copied[@]} file(s): ${copied[*]}"
        fi
        cd "$worktree_path"
    fi
}

# gwtrm: Remove worktree with fzf
function gwtrm() {
    if ! git rev-parse --is-inside-work-tree &> /dev/null; then
        echo "Not a git repository"
        return 1
    fi
    local selected=$(git worktree list | tail -n +2 | fzf --prompt="Remove worktree: " | awk '{print $1}')
    if [ -n "$selected" ]; then
        git worktree remove "$selected"
    fi
}

# ---------------------
# Completion system
# ---------------------
autoload -Uz compinit
compinit

# ---------------------
# GitHub CLI
# ---------------------
if command -v gh &> /dev/null; then
    eval "$(gh completion -s zsh)"
fi
